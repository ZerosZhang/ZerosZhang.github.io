[{"content":"先进封装 🦪https://www.bilibili.com/video/BV1Yu411c7ic\n所谓封装，就是给芯片加壳后再连接电路。\n传统的封装 半导体的后道工艺通常包含以下内容：\n而本文会着重解释键合和封装的工艺。传统的键合是先进行芯片键合，再进行引线键合，然后套一层壳。\n芯片键合——Die Bonding 引线键合——Wire Bonding 倒装芯片键合——Filp Chip Bonding 🦪 传统封装的缺点：\n引线框架比较大——芯片体积大 金属引线比较长——信号传输耗时长 封装的发展 裸片贴装——引线键合 倒片封装——焊球/凸点 晶圆级封装——RDL 重布线层 2.5D/3D 封装——TSV 硅通孔技术，chiplet 封装技术 🦪 每一代技术之间的本质区别，就是芯片和电路之间连接方式的区别\n倒片封装 芯片电路层朝下，通过金属球将芯片与电路连接，有效减少了芯片的体积，提升了传输速率。\n需要用到曝光，刻蚀，沉积等工艺。\n晶圆级封装 这种叫做扇入型封装。该封装方式的缺点在于芯片的保护性不强，且可能会导致后续发生变形。\n这种方式叫做扇出型封装，在扇入的基础上增加一层保护壳。\n2.5D/3D 封装 将两个芯片放在同一块硅中介层上，再将其放在 PCB 板上，作为一个完整的芯片。\n这种方式的做法是可以有效的增加两块芯片之间的通信效率。\n3D 封装去除了硅中介层，将芯片与芯片直接相连。\n3D 封装依赖于 TSV 硅通孔技术，即在硅上打通孔，然后在通孔上填充金属材料，这样就可以把芯片一层一层的串联起来。\nChiplet 芯粒：一种按照功能对现有逻辑芯片进行拆分并使用硅通孔堆叠实现互联的技术。\n","date":"2025-05-24T19:50:14+08:00","image":"https://zeroszhang.github.io/p/%E5%85%88%E8%BF%9B%E5%B0%81%E8%A3%85/Title.jpg","permalink":"https://zeroszhang.github.io/p/%E5%85%88%E8%BF%9B%E5%B0%81%E8%A3%85/","title":"先进封装"},{"content":"芯片键合（Die Bond） 参考：https://blog.csdn.net/qq_46675545/article/details/128050411?spm=1001.2014.3001.5502\n🦪芯片键合工艺在划片工艺之后将从晶圆上切割的芯片黏贴在封装基板（引线框架或印刷电路板）上，来实现芯片与外部之间的电连接。\n键合工艺可分为传统方法和先进方法两种类型。传统方法采用芯片键合Die Bonding和引线键合Wire Bonding，而先进方法则采用 IBM 于 60 年代后期开发的倒装芯片键合Flip Chip Bonding技术。倒装芯片键合技术将芯片键合与引线键合相结合，并通过在芯片焊盘上形成凸块Bump的方式将芯片和基板连接起来。\n芯片拾取与放置Pick \u0026amp; Place 逐个移除附着在切割胶带上数百个芯片的过程称为“拾取Pick”。使用柱塞从晶圆上拾取合格芯片并将其放置在封装基板表面的过程称为“放置Place”。这两项任务合称为“拾取与放置Pick\u0026amp;Place”，均在固晶机（用于芯片键合的装置）上完成。完成对所有合格芯片的芯片键合之后，未移除的不合格芯片将留在切割胶带上，并在框架回收时全部丢弃。在这个过程中，将通过在映射表（Mapping图）中输入晶圆测试结果（合格/不合格）的方式对合格芯片进行分类。\n","date":"2025-05-24T19:39:45+08:00","image":"https://zeroszhang.github.io/p/%E8%8A%AF%E7%89%87%E9%94%AE%E5%90%88/Title.jpg","permalink":"https://zeroszhang.github.io/p/%E8%8A%AF%E7%89%87%E9%94%AE%E5%90%88/","title":"芯片键合"},{"content":"红黑树诞生的背景 普通的二叉搜索树在添加有序数据（递增或者递减）的时候，所有的节点都会在根节点的右侧或者左侧，此时普通的二叉树就退化成链表，操作的时间复杂组退化成了$O(N)$。\n于是就有了平衡二叉树（AVL 树）。平衡二叉树通过平衡因子来限制树的解构——任意节点的子树的高度差都小于等于 1。将查询效率优化为了$\\log _{2} n$。\nAVL 树作为严格平衡的二叉树，就需要频繁的通过旋转操作来保持平衡，而旋转操作是比较耗时的，导致了维护这种高度平衡所付出的代价比从中获得的收益还大，因此只适用于插入删除次数较少，但是查找多的情况。\n在上面的大背景下，诞生了红黑树，即使在最坏的情况下，也可以在$ \\log _{2} n$时间内实现插入/删除/查找操作。\n红黑树是一个弱平衡二叉树，相比于严格平衡的 AVL 树，每次树的结构发生改变需要调整时，所需要的转换次数更少，因此对于插入和删除操作的效率更高。\n红黑属性的意义 为了确保红黑树的弱平衡属性，要求没有任何一条路径比其他路径长出两倍。因此在每个节点上增加了颜色属性——红或者黑。\n红黑属性通过颜色规则来保持树的平衡，减少旋转操作。每次改变了树的结构（插入/删除操作）之后，最多只需要两次旋转操作即可完成树的平衡。\n红黑树的性质 红黑树有五条性质，记住后面两条就行：\n每个节点非红即黑 根节点是黑的 每个叶节点（树尾端 NULL 节点）都是黑的 如果一个节点是红的,那么它的两儿子都是黑的1 任意节点到每个叶子节点的所有路径都包含相同数目的黑节点 节点的定义 红黑树的着色和旋转 在插入/删除节点的时候，会破坏红黑树的性质，因此需要调整红黑树的结构，以满足上述性质。总共包含三种调整的操作——着色/左旋/右旋。\n着色指的是将红色节点变为黑色节点，或者黑色节点变为红色节点。\n左旋操作如下所示：\n右旋操作如下所示：\n红黑树中的红黑属性并非唯一 红黑树的颜色属性情况并非只有唯一解，只要保证满足红黑树性质即可。如下所示，在插入 101 后删除 101，红黑树还是原来的红黑树，但是颜色属性变化了。\n红黑树的插入操作 这里有一个规则，新插入的节点一定是红色的。因为红色节点可能不会影响平衡2，但是黑色节点一定会影响树的平衡3。默认插入红色节点可以减少后续操作。\n红黑树的插入操作分为四种情况：\n🦪以下的「父节点」「叔叔节点」「祖父节点」都是插入新节点后，调整树结构前的状态（图 2 中）\n父节点为黑 🧋 直接插入新元素，不需要调整树的结构。\n父节点为红色，叔叔节点为红色 🧋「父节点」和「叔叔节点」变黑，「祖父节点」变红，递归检查祖父节点是否引发新的冲突。\n如图 1，插入节点 120。父节点是 110，叔叔节点是 90，符合该情况。因此将父节点 110 和叔叔节点 90 变黑，祖父节点 100 变红。引发性质 2 冲突，因此将祖父节点 100 变黑。\n父节点为红色，叔叔节点为黑色，且父子同侧（LL/RR 型） 🧋左左型（LL）：右旋「祖父节点」。「父节点」变黑，「祖父节点」变红。\n🧋右右型（RR）：左旋「祖父节点」。「父节点」变黑，「祖父节点」变红。\n例1：插入节点 70。父节点 80 为红色，叔叔节点 null 为黑色，且父节点 80 和目标节点 70 都是左子节点，为 LL 型。因此对祖父节点 90 进行右旋。父节点 80 变黑，祖父节点 90 变红。\n例2：插入节点 97。父节点 95 为红色，叔叔节点 null 为黑色，且父节点 95 和目标节点 97 都是右子节点，为 RR 型。因此对祖父节点 90 进行右旋。父节点 95 变黑，祖父节点 90 变红。\n父节点为红色，叔叔节点为黑色，且父子异侧（LR/RL 型） 🧋左右型（LR）：先左旋「父节点」，再右旋「祖父节点」。「目标节点」变黑，「祖父节点」变红4。\n🧋右左型（RL）：先右旋「父节点」，再左旋「祖父节点」。「目标节点」变黑，「祖父节点」变红5。\n例1：插入节点 85。父节点 80 为红色，叔叔节点 null 为黑色，且父节点 80 是左子节点，目标节点 85 是右子节点，为 LR 型。因此先对父节点 80 进行左旋，再对祖父节点 90 进行右旋。目标节点 85 变黑，祖父节点 90 变红。\n例2：插入节点 92。父节点 95 为红色，叔叔节点 null 为黑色，且父节点 95 是右子节点，目标节点 92 是左子节点，为 RL 型。因此先对父节点 95 进行右旋，再对祖父节点 90 进行左旋。目标节点 92 变黑，祖父节点 90 变红。\n红黑树的删除操作 🧋「当前节点」指的是删除了「目标节点」后，替换了「目标节点」位置的节点。\n删除单个红节点 🧋 单个红节点指的是左右子节点都是 null 的节点。不会影响红黑树的性质，因此可以直接删除。\n删除单个黑节点 🧋 单个黑节点指得是左右子节点都是 null 的节点。\n兄弟节点是黑色，且远侄节点为红：旋转父节点，兄弟节点颜色变为父节点的颜色，父节点和远侄节点变黑。 兄弟节点是黑色，近侄节点为红，远侄节点为黑：旋转兄弟节点，近侄节点变黑，兄弟节点变红。转换为兄弟节点为黑，远侄节点为红。 兄弟节点为黑，且侄节点全黑：兄弟节点变红，将问题上移至父节点，递归处理。 兄弟节点为红：旋转父节点，兄弟节点变黑，父节点变红，转换成兄弟节点为黑的情况。 例1：删除节点 70。兄弟节点 100 是黑色，近侄节点 90 是红色，远侄节点 null 是黑色，为情况 2。删除节点 70 后，使用 null 节点代替，作为当前节点。\n兄弟节点 100 右旋，近侄节点 90 变黑，兄弟节点 100 变红。\n此时并没有调整完成，以 null 节点为目标节点，转换成兄弟节点 90 为黑，远侄节点 100 为红的情况。左旋父节点 80，兄弟节点 90 颜色变为父节点 80 的颜色（此处为黑色），父节点 80 和远侄节点 100 变黑。\n例2：删除节点 120。兄弟节点是红色，为情况 4。删除节点 120 后，使用 null 节点代替，作为当前节点。\n右旋父节点 100，兄弟节点 80 变黑，父节点 100 变红。\n此时并没有调整完成，以 null 节点为目标节点，转换成兄弟节点 90 为黑，侄节点全黑的情况。兄弟节点 90 变红，并递归检查。\n删除只包含一个子节点的黑色节点，该节点只可能是红色节点 只包含一个子节点时，这是唯一情况。目标节点为红色或者子节点为黑色，都会破坏红黑树的性质。\n🧋 目标节点替换为红色子节点，且子节点变为黑色。\n删除包含两个子节点的节点（不论红黑） 🧋 使用「左子树的最右节点6」代替该节点，颜色保持一致，仅替换内容。然后删除最右节点（跳转其他情况）。\n红黑树的原理 (插入+ 删除) 案例分析\n红黑树可视化网站\n红色节点不会连续出现\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n可能违反违反性质 4\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n可能违反性质 4，一定违反性质 5\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n左旋「父节点」之后，已经转化成了 LL 型的情况。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n右旋「父节点」之后，已经转化成了 RR 型的情况。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n也可以右子树的最左节点\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-05-24T00:00:00Z","image":"https://zeroszhang.github.io/p/%E7%BA%A2%E9%BB%91%E6%A0%91/title.jpg","permalink":"https://zeroszhang.github.io/p/%E7%BA%A2%E9%BB%91%E6%A0%91/","title":"红黑树"},{"content":"最近发现 Halcon 的官方手册写得很好，于是详细阅读并做笔记。\n在我的笔记系统中包含以下文档的中文翻译：\nSolution Guide I.pdf Solution Guide II-A.pdf Solution Guide II-B.pdf Solution Guide II-C.pdf Solution Guide II-D.pdf Solution Guide III-A.pdf Solution Guide III-B.pdf Solution Guide III-C.pdf 文档中的案例都做了详细的笔记：\n部分例程学习后整理上传到此处：Halcon 例程\n","date":"2025-02-20T15:55:19+08:00","image":"https://zeroszhang.github.io/p/halcon%E4%BE%8B%E7%A8%8B%E7%AC%94%E8%AE%B0/Title.jpg","permalink":"https://zeroszhang.github.io/p/halcon%E4%BE%8B%E7%A8%8B%E7%AC%94%E8%AE%B0/","title":"Halcon例程笔记"},{"content":"关于 Microsoft Rewards Microsoft Rewards 是微软出品的一款软件，可以通过搜索 Bing 来获取奖励，奖励的种类有很多，包括现金、积分、礼品等。但是我老是忘记搜索 Bing，因此就实现了一个软件，帮助我每天自动搜索 Bing。\n我并没有将该功能添加到 ZerosTodo 中，因为我并不希望该功能影响我正常使用电脑，所以我拿了一个老笔记本安装了 Windows Server 2016，当作我的服务器。\n另外，Rewards 也有手机端的搜索任务，但是手机我是随身带着，所以我并没有实现安卓端的软件，直接使用油猴脚本进行替代。\n关于 RewardsAutoMate 自动搜索功能 该软件用于在 PC 端获取随机的搜索关键词，自动搜索 Bing，每天搜索 40 次，每隔 12 个小时执行一次任务。如果当天已经完成了任务，则不会继续执行。\n热力图功能 为了记录每天的搜索情况，该软件会生成如 Github 的热力图，用于记录每天的搜索情况。\n自动登录功能 Rewards 和微软账号相关，所以在打开 EdgeDriver 时，要调用本地的账户信息进行登录。\n项目代码上传到此处：RewardsAutoMate\n更新记录 2025年4月18日 更新：通过 UserAgent 伪装成移动设备，这样可以在 PC 端实现移动端的搜索。 ","date":"2025-02-06T15:44:39+08:00","image":"https://zeroszhang.github.io/p/microsoft-rewards-%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96%E5%8A%A9%E6%89%8B/Title.jpg","permalink":"https://zeroszhang.github.io/p/microsoft-rewards-%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96%E5%8A%A9%E6%89%8B/","title":"Microsoft Rewards 自动获取助手"},{"content":"3D设计软件 FreeCAD https://github.com/FreeCAD/FreeCAD\n日常工作需要审核机械设计师在 Solidworks 中绘制的 3D 图纸，于是就下了这个开源软件。该软件还支持 3D 设计，但是我没有这种需求。\n让我同事在 Solidworks 中导出 Step 文件，再在 FreeCAD 中打开即可。第一次打开 step 时要设置文本编码方式，选择 GBK，否则 step 文件中的中文会乱码。\n远程桌面 1Remote https://github.com/1Remote/1Remote\n开源软件，该软件可以记录多个远程桌面的配置（IP地址+用户+密码），下次使用双击打开即可。\nRSS阅读 Follow https://github.com/RSSNext/follow\n开源软件，可以使用RSS订阅很多网站，这样每天只要打开 Follow 就可以看到很多网站的更新。另外还有一点好处是可以看到其他用户订阅的内容，这样可以扩展自己的知识面。\n这个软件的功能是受限的，想解锁需要激活码，我是问别人要的。\n笔记软件 Wolai https://www.wolai.com/\n国内仿 Notion 比较好的软件，挺好用，需要按年开会员，否则功能受限。\n输入法中英文提示软件 InputTip https://github.com/abgox/InputTip\n写代码的时候需要频繁切换中英文，老是忘记看右下角，有了这个软件之后在输入的地方就会有一个悬浮图标指示大写/中文/英文。\n截图软件 PixPin https://pixpin.cn/\n贼好用的截图软件，完全覆盖了 Snipaste 的功能，除此以外可以离线OCR，长截图，录制Gif，功能很多。\n文件同步软件 坚果云 https://www.jianguoyun.com/\n可以无感同步文件，在不同的电脑上访问，我用的是免费的 1G 空间，同步一些日常用的文件。\n数据库管理软件 Heidi SQL https://www.heidisql.com/\n开源的数据库管理软件，支持很多类型的连接。\n视频播放器 PotPlayer http://www.potplayercn.com/\n贼好用的视频播放器，功能很多，比如倍速播放，看直播源等等。\nMarkdown编辑器 Typora 好用的 Markdown 编辑器，比其他的编辑器都好用，主要是很方便预览。\nhttps://typora.io/\n简易CSharp编辑器 LinqPad 8 https://www.linqpad.net/\n很方便的 C# 编辑器，使用 BenchMark 特别方便，跟写 Python 一样。\n多功能编辑器 VSCode https://code.visualstudio.com/\n支持的文件很多，比如装插件可以看 SQL.db 文件，可以看 Excel 文件，算是高级文本编辑器。\n还可以使用 Polyglot NoteBook 写 C#，跟 Jupyter NoteBook 类似，但是会有一些限制，而且代码提示没有 LinqPad 8 好用。\n文本编辑器 Notpad\u0026ndash; https://gitee.com/cxasm/notepad--\n选择这个文本编辑器有几点原因：\n操作逻辑和VS2022相同 不用折腾 支持多标签 多功能启动器 uTools https://www.u.tools/\n神。\n右键菜单美化 NileSoft Shell https://nilesoft.org/\n升级 Windows 11 后右键菜单不是很好用，所以下了这个软件，给右键菜单新增了额外的功能，并且颜值很高。\n这个软件有个问题，发送到这个菜单显示空白，我两台电脑都有这个问题，但是我在网上没搜到相同的问题。\n快速预览 QuickLook https://github.com/QL-Win/QuickLook\n跟 MacOS 一样的按空格预览文件的功能。需要额外下载插件，我下载了DrawIO，Office预览。\n","date":"2025-01-17T16:41:10+08:00","image":"https://zeroszhang.github.io/p/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/Title.jpg","permalink":"https://zeroszhang.github.io/p/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/","title":"软件推荐"},{"content":"碰到的问题 在日常的工作中，碰到几个问题：\n经常忘记个别要做的事情 某个事情做完几天后，忘记了当时的情况 因此就实现了一个软件 ZerosTodo ，帮助我日常更方便的工作。\n这个软件目前（2025 年 2 月 6 日）包含两个功能：\n从 wolai 的特定页面中获取最近要做的几个事情 每隔 5 秒截图屏幕并保存 对于需求 1，为了区别于正常的待办软件，我的软件里并没有待办的概念，而是直接把最近要做的几个事情显示在软件的界面上，并置顶悬浮于所有软件上面。我在屏幕专门留了一个角落给他。\n对于需求 2，我遍历当前所有的屏幕，并对每个屏幕截图，按照日期保存到指定的文件夹中。同时，为了避免硬盘占用太多，额外新增了一个配置项，超过 90 天的文件夹将会被删除。\n项目代码上传到此处：ZerosTodo\n更新记录 2025 年 3 月 18 日更新：新增文字朗读的功能，优化 UI 界面。这个功能可以上传 TxT 文件，并调用 Windows 的语音包朗读内容。\n2025 年 5 月 26 日更新：新增朗读剪贴板文字的功能。在常驻窗口中增加了一个小按钮，让我可以方便的使用该功能。\n","date":"2025-01-17T16:39:45+08:00","image":"https://zeroszhang.github.io/p/zerostodo-%E4%B8%AA%E4%BA%BA%E5%8A%A9%E6%89%8B/Title.jpg","permalink":"https://zeroszhang.github.io/p/zerostodo-%E4%B8%AA%E4%BA%BA%E5%8A%A9%E6%89%8B/","title":"ZerosTodo 个人助手"},{"content":"关于笔记软件 迄今为止，我使用过一些笔记软件，比如 AnyType，Notion，语雀，思源，Obsidian，Logseq，TiddlyWiki，Trilium，Joplin，飞书，wolai 等软件，最终我的选择是 wolai，原因是「中文」和「不用折腾插件/同步等问题」。\n另外其他几个软件都或多或少有一些不是很符合我需求的问题：\nTiddlyWiki：用法比较奇怪，会把所有的笔记记录到一个 HTML 文件中，我不太习惯。 飞书：「画布」功能是所有软件里做的最好的，能够把「流程图」和「思维导图」合并在一起，但是飞书软件太大了，而且得安装插件才可以导出 Markdown 格式。 Obsidian：网上特别多人使用的笔记软件，有插件系统，可以说是一个笔记版本的 VSCode，但是太折腾了。 语雀：之前使用的笔记软件，并且在该平台上创建了我第一版博客，后来语雀必须冲会员才能公开博客，所以我就放弃了。 wolai 是国内仿 Notion 很成功的一款软件，最近还被阿里巴巴收购了，合并到钉钉个人版中。由于免费版能使用的功能较少，所以我买了 6 年的会员。\n在此推荐：https://www.wolai.com/signup?invitation=7VKA7NI\n笔记结构 我大致将我的笔记分为以下几个部分：\n临时缓存：用于存储网页分享，微信助手，临时记录等内容 时光记录：个人日记 读书笔记：包含看过的书/论坛/网页等的总结和注释 文档：技术性的一些文档，如 C#/自动化/视觉/OpenCV/OpenGL 等 折腾记录：一些零碎的知识点 标签：都是空白的页面，给其他页面引用，以实现 wolai 中没有的标签系统 归档：草稿内容 博客更新笔记内容 由于我的笔记中内容太多，并且有很多内容不适合公开，因此该博客内，仅更新部分我觉得比较好的内容，可以点击 笔记 标签查找这部分内容。\n","date":"2025-01-17T16:38:10+08:00","image":"https://zeroszhang.github.io/p/%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/title.jpg","permalink":"https://zeroszhang.github.io/p/%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/","title":"我的笔记系统"},{"content":"简介 BaseWPFControl 是一个 dll，基于 .net 8.0 和 WPF 框架实现，用于提供控件样式（包含基础控件和额外控件）。\n基础控件 Button 重写了基础控件 Button 的样式。\n新增 BaseWPFControl:ButtonProperty.Icon 附加属性用于提供按钮图标 提供圆角 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;Button Content=\u0026#34;纯文字按钮\u0026#34; Margin=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;图标\u0026#34; Margin=\u0026#34;10\u0026#34; BaseWPFControl:ButtonProperty.Icon=\u0026#34;{StaticResource HomePage}\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;圆形按钮\u0026#34; Margin=\u0026#34;10\u0026#34; Style=\u0026#34;{StaticResource CircleButtonStyle}\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;带图标的圆形按钮\u0026#34; Margin=\u0026#34;10\u0026#34; Style=\u0026#34;{StaticResource CircleButtonStyle}\u0026#34; BaseWPFControl:ButtonProperty.Icon=\u0026#34;{StaticResource HomePage}\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;跑道形按钮\u0026#34; Margin=\u0026#34;10\u0026#34; Style=\u0026#34;{StaticResource RoundButtonStyle}\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;图标\u0026#34; Margin=\u0026#34;10\u0026#34; Style=\u0026#34;{StaticResource RoundButtonStyle}\u0026#34; BaseWPFControl:ButtonProperty.Icon=\u0026#34;{StaticResource HomePage}\u0026#34; /\u0026gt; 针对不启用和不可点击的按钮，做出了区分，分别对应 IsEnabled 和 IsHitTestVisible 属性。\n1 2 \u0026lt;Button Content=\u0026#34;不启用\u0026#34; IsEnabled=\u0026#34;False\u0026#34; Margin=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;Button Content=\u0026#34;不可点击\u0026#34; IsHitTestVisible=\u0026#34;False\u0026#34; Margin=\u0026#34;10\u0026#34; /\u0026gt; 之所以这样去做目的是为了 GPIO 的控制，GPI 不可点击，GPO 可点击。\n提供了两种相似的样式 BooleanStateButtonStyle 和 BooleanToggleButtonStyle。前者对应于 GPI，不可点击，仅用于展示 GPI 状态，后者对应于 GPO，既可以展示 GPO 状态，又可以通过点击切换状态。\n1 2 3 4 \u0026lt;Button Style=\u0026#34;{StaticResource BooleanStateButtonStyle}\u0026#34; Margin=\u0026#34;10\u0026#34; Tag=\u0026#34;{Binding State}\u0026#34; /\u0026gt; \u0026lt;Button Style=\u0026#34;{StaticResource BooleanToggleButtonStyle}\u0026#34; Margin=\u0026#34;10\u0026#34; Tag=\u0026#34;{Binding State}\u0026#34; Command=\u0026#34;{Binding ChangeStateCommand}\u0026#34; /\u0026gt; ToggleButton 基于 ToggleButton 重写样式，该控件的本意是用于 GPIO 的控制\n1 2 3 \u0026lt;ToggleButton IsChecked=\u0026#34;{Binding State}\u0026#34; Margin=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;ToggleButton IsChecked=\u0026#34;{Binding State}\u0026#34; Margin=\u0026#34;10\u0026#34; IsEnabled=\u0026#34;False\u0026#34; /\u0026gt; 最终方案如下：\nGPI 使用 Button 的 BooleanStateButtonStyle 样式 GPO 使用 ToggleButton 的默认样式。 RadioButton 重写 RadioButton 的样式，主要优化如下：\n勾选后样式变化 勾选框尺寸跟随字体尺寸变化 1 2 3 4 5 \u0026lt;RadioButton Content=\u0026#34;未勾选\u0026#34; /\u0026gt; \u0026lt;RadioButton Content=\u0026#34;勾选\u0026#34; IsChecked=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;RadioButton Content=\u0026#34;未勾选未启用\u0026#34; IsEnabled=\u0026#34;False\u0026#34; IsChecked=\u0026#34;False\u0026#34; /\u0026gt; \u0026lt;RadioButton Content=\u0026#34;勾选未启用\u0026#34; IsEnabled=\u0026#34;False\u0026#34; IsChecked=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;RadioButton Content=\u0026#34;大字体\u0026#34; FontSize=\u0026#34;30\u0026#34; /\u0026gt; CheckBox 重写 CheckBox 的样式，主要优化如下：\n勾选后样式变化 勾选框圆角 勾选框尺寸跟随字体尺寸变化 1 2 3 4 5 \u0026lt;CheckBox Content=\u0026#34;未勾选\u0026#34; /\u0026gt; \u0026lt;CheckBox Content=\u0026#34;勾选\u0026#34; IsChecked=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;CheckBox Content=\u0026#34;未勾选未启用\u0026#34; IsEnabled=\u0026#34;False\u0026#34; IsChecked=\u0026#34;False\u0026#34; /\u0026gt; \u0026lt;CheckBox Content=\u0026#34;勾选未启用\u0026#34; IsEnabled=\u0026#34;False\u0026#34; IsChecked=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;CheckBox Content=\u0026#34;大字体\u0026#34; FontSize=\u0026#34;30\u0026#34; /\u0026gt; ComboBox 重写 ComboBox 样式，主要优化如下：\n圆角属性 提供 ComboBox 绑定枚举值的扩展语法 EnumBindingSource 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!--示例1：ComboBox绑定枚举值--\u0026gt; \u0026lt;ComboBox Margin=\u0026#34;10\u0026#34; Width=\u0026#34;120\u0026#34; ItemsSource=\u0026#34;{BaseWPFControl:EnumBindingSource EnumType=BaseTest:EnumDayOfWeek}\u0026#34; SelectedItem=\u0026#34;{Binding SelectedEnumDayOfWeek}\u0026#34; \u0026gt; \u0026lt;ComboBox.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Converter={StaticResource EnumToDescriptionConverter}, Mode=OneWay}\u0026#34; /\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ComboBox.ItemTemplate\u0026gt; \u0026lt;/ComboBox\u0026gt; \u0026lt;!--示例2：不启用ComboBox--\u0026gt; \u0026lt;ComboBox Margin=\u0026#34;10\u0026#34; Width=\u0026#34;120\u0026#34; IsEnabled=\u0026#34;False\u0026#34; \u0026gt; \u0026lt;ComboBoxItem Content=\u0026#34;1\u0026#34; IsSelected=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;/ComboBox\u0026gt; \u0026lt;!--示例3：ComboBox绑定字典--\u0026gt; \u0026lt;!--note：需要设置 DisplayMemberPath 和 SelectedValuePath，--\u0026gt; \u0026lt;!--note：并只能使用 SelectedValue 进行访问--\u0026gt; \u0026lt;ComboBox Margin=\u0026#34;10\u0026#34; Width=\u0026#34;120\u0026#34; ItemsSource=\u0026#34;{Binding DictionaryDayOfWeek}\u0026#34; DisplayMemberPath=\u0026#34;Value\u0026#34; SelectedValuePath=\u0026#34;Key\u0026#34; SelectedValue=\u0026#34;{Binding SelectedDictionaryDayOfWeek}\u0026#34; /\u0026gt; \u0026lt;!--示例4：ComboBox绑定列表--\u0026gt; \u0026lt;!--note：使用 SelectedItem 或者 SelectedValue 都可以获得正确结果--\u0026gt; \u0026lt;!--note: 前提是绑定的值在列表中，也可以通过 SelectedIndex 进行访问--\u0026gt; \u0026lt;ComboBox Margin=\u0026#34;10\u0026#34; Width=\u0026#34;120\u0026#34; ItemsSource=\u0026#34;{Binding ListDayOfWeek}\u0026#34; SelectedItem=\u0026#34;{Binding SelectedListDayOfWeek}\u0026#34; /\u0026gt; TextBlock 重写 TextBlock 的样式，主要优化如下：\n中英文使用不同的字体显示，中文使用微软雅黑，英文使用Consolas 1 2 \u0026lt;TextBlock Text=\u0026#34;显示中文\u0026#34; Margin=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Show English\u0026#34; Margin=\u0026#34;10\u0026#34; /\u0026gt; MemoryBlock 该控件为自定义控件，主要实现以下功能：\n获取当前软件已使用内存，以 MB 为单位 可以通过控件的 Interval 属性设置更新频率，单位为 ms，默认为 1000 ms 可以通过控件的 Header 属性设置前缀文字 可以通过控件的 UsedMemory 只读属性获取内存 1 \u0026lt;BaseWPFControl:MemoryBlock Margin=\u0026#34;10\u0026#34; /\u0026gt; LogBlock 该控件为自定义控件，配合 BaseLogManager 一起使用，主要实现以下功能：\n显示日志 提供日志详情页 1 2 3 4 \u0026lt;BaseWPFControl:LogBlock x:Name=\u0026#34;LogBlock_Test\u0026#34; /\u0026gt; \u0026lt;ContentControl Height=\u0026#34;400\u0026#34; Margin=\u0026#34;10\u0026#34; Content=\u0026#34;{Binding ElementName=LogBlock_Test, Path=LogView}\u0026#34; /\u0026gt; TextBox 重写 TextBox 的样式，主要实现以下功能：\n可以通过 TextBoxProperty.Prefix 属性设置前缀文字 可以通过 TextBoxProperty.WaterMask 属性设置水印文字 可以通过 TextBoxProperty.Suffix 属性设置后缀文字 输入时边框高亮显示 大文本输入框可以通过滚动条上下滚动 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;TextBox Width=\u0026#34;200\u0026#34; Margin=\u0026#34;10\u0026#34; BaseWPFControl:TextBoxProperty.Prefix=\u0026#34;www.\u0026#34; BaseWPFControl:TextBoxProperty.Suffix=\u0026#34;.com\u0026#34; BaseWPFControl:TextBoxProperty.WaterMask=\u0026#34;输入网址\u0026#34; /\u0026gt; \u0026lt;TextBox Width=\u0026#34;160\u0026#34; Margin=\u0026#34;10\u0026#34; Text=\u0026#34;默认文本框\u0026#34; /\u0026gt; \u0026lt;TextBox Width=\u0026#34;100\u0026#34; Margin=\u0026#34;10\u0026#34; BaseWPFControl:TextBoxProperty.WaterMask=\u0026#34;绑定Decimal类型\u0026#34; Text=\u0026#34;{Binding DecimalNumber, StringFormat=0.#}\u0026#34; /\u0026gt; \u0026lt;TextBox Style=\u0026#34;{StaticResource BigTextBox}\u0026#34; Width=\u0026#34;400\u0026#34; Height=\u0026#34;100\u0026#34; Margin=\u0026#34;10\u0026#34; Text=\u0026#34;{Binding Poetry1}\u0026#34; /\u0026gt; NumericBox NumericBox 为自定义控件，主要实现以下功能：\n更方便的绑定数字，并提供限制 可以通过 Value 属性获取/设置值 可以通过 TextFormat 属性设置文本格式 可以通过 MinValue 属性设置最小值 可以通过 MaxValue 属性设置最大值 可以通过 Interval 属性设置点击增减按钮时的变化量 可以通过 ValueChanged 事件获取值改变事件 1 2 3 4 5 \u0026lt;BaseWPFControl:NumericBox Value=\u0026#34;{Binding DecimalNumber}\u0026#34; TextFormat=\u0026#34;0.#\u0026#34; MinValue = \u0026#34;0\u0026#34; MaxValue = \u0026#34;100\u0026#34; Interval = \u0026#34;1\u0026#34; ValueChanged=\u0026#34;NumericBox_ValueChanged\u0026#34; /\u0026gt; \u0026lt;BaseWPFControl:NumericBox Value=\u0026#34;{Binding DecimalNumber}\u0026#34; TextFormat=\u0026#34;0.#\u0026#34; IsEnabled=\u0026#34;False\u0026#34; /\u0026gt; PasswordBox 重写 PasswordBox 样式，主要实现以下功能：\n可以通过 PasswordBoxProperty.CanShowPassword 属性设置是否显示密码的功能 1 2 3 \u0026lt;PasswordBox Width=\u0026#34;200\u0026#34; Margin=\u0026#34;10\u0026#34; Password=\u0026#34;123456\u0026#34; /\u0026gt; \u0026lt;PasswordBox Width=\u0026#34;200\u0026#34; Margin=\u0026#34;10\u0026#34; Password=\u0026#34;123456\u0026#34; BaseWPFControl:PasswordBoxProperty.CanShowPassword=\u0026#34;False\u0026#34; /\u0026gt; DatePicker \u0026amp; DateTimePicker DatePicker 和 DateTimePicker 都是自定义控件，主要实现以下功能：\n选择时间和日期，这两个控件的区别在于一个前者只有日期，后者包含时间 可以通过 SelectedDateTime 获取选中的日期时间 可以通过 SelectedDateTimeFormat 设置日期时间的格式 可以通过 SelectedDateTimeChanged 获取时间改变的事件 1 2 \u0026lt;BaseWPFControl:DatePicker Margin=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;BaseWPFControl:DateTimePicker Margin=\u0026#34;10\u0026#34; /\u0026gt; SelectFileBlock \u0026amp; SelectFolderBlock SelectFileBlock 和 SelectFolderBlock 都是自定义控件，主要实现以下功能：\n点击按钮通过对话框选择文件或者文件夹 可以通过 SelectedPath 属性获取/设置路径 可以通过 SelectedPathChanged 获取选中路径改变的事件 SelectFileBlock 可以通过 ExtensionFilter 属性设置文件过滤 鼠标移动到文字上方出现 ToolTip 显示路径的全文 鼠标双击文字直接跳转到路径所在的文件夹 Image 提供一些内置的 SVG，可以直接通过 Source 绑定 StaticResource 值进行设置\n1 \u0026lt;Image Source=\u0026#34;{StaticResource DirectoryConfig}\u0026#34; Height=\u0026#34;50\u0026#34; Margin=\u0026#34;10\u0026#34; /\u0026gt; ProgressBar \u0026amp; Loading 重写 ProgressBar 样式，提供圆角 可以通过 ProgressBarProperty.ShowValue 属性设置进度条显示当前值 提供扩展函数 SetAnimateValue 设置进度条的值，通过该函数设置可以显示动画 提供自定义控件圆形进度条 Loading，仅用于等待功能 1 2 3 4 \u0026lt;ProgressBar Height=\u0026#34;40\u0026#34; Width=\u0026#34;400\u0026#34; d:Value=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;ProgressBar Height=\u0026#34;40\u0026#34; Width=\u0026#34;400\u0026#34; IsIndeterminate=\u0026#34;True\u0026#34;/\u0026gt; \u0026lt;BaseWPFControl:Loading Diameter=\u0026#34;150\u0026#34; StrokeThickness=\u0026#34;30\u0026#34; Content=\u0026#34;加载中，请等待...\u0026#34; /\u0026gt; Clock \u0026amp; Calendar 重写 Calender 样式 提供 自定义控件 Clock，用于选择时间 1 2 3 \u0026lt;Calendar x:Name = \u0026#34;Calendar\u0026#34; /\u0026gt; \u0026lt;BaseWPFControl:Clock Height=\u0026#34;{Binding ActualHeight, ElementName=Calender}\u0026#34;/\u0026gt; TabControl 重写 TabControl 的样式\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;TabControl TabStripPlacement=\u0026#34;Left\u0026#34;\u0026gt; \u0026lt;TabItem Header=\u0026#34;水调歌头\u0026#34; \u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Poetry1}\u0026#34; FontSize=\u0026#34;14\u0026#34; /\u0026gt; \u0026lt;/TabItem\u0026gt; \u0026lt;TabItem Header=\u0026#34;如梦令\u0026#34; \u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Poetry2}\u0026#34; FontSize=\u0026#34;14\u0026#34; /\u0026gt; \u0026lt;/TabItem\u0026gt; \u0026lt;TabItem Header=\u0026#34;破阵子\u0026#34; \u0026gt; \u0026lt;TextBlock Text=\u0026#34;{Binding Poetry3}\u0026#34; FontSize=\u0026#34;14\u0026#34; /\u0026gt; \u0026lt;/TabItem\u0026gt; \u0026lt;TabItem Header=\u0026#34;未启用\u0026#34; IsEnabled=\u0026#34;False\u0026#34; /\u0026gt; \u0026lt;/TabControl\u0026gt; 复杂控件 ConfigControl 提供自定义控件 ConfigControl，用于方便的实现配置界面\n1 2 3 4 5 6 7 \u0026lt;BaseWPFControl:ConfigControl ConfigName=\u0026#34;日期时间\u0026#34;\u0026gt; \u0026lt;BaseWPFControl:DateTimePicker /\u0026gt; \u0026lt;/BaseWPFControl:ConfigControl\u0026gt; \u0026lt;BaseWPFControl:ConfigControl ConfigName=\u0026#34;选择文件\u0026#34;\u0026gt; \u0026lt;BaseWPFControl:SelectFileBlock Width=\u0026#34;280\u0026#34; /\u0026gt; \u0026lt;/BaseWPFControl:ConfigControl\u0026gt; LisBox 重写 ListBox 的样式，可以绑定 Enum/List/Dictionary\nListView 重写 ListView 的样式 DataGrid 重写 DataGrid 的样式，这里包含两种样式，一种是选择单元格，另一种是鼠标经过选中整行\n更新记录 更新了部分 BaseWPFControl 中的控件，实现了更多的功能。\n优化ListBox 实际使用了一下ListBox之后发现还是有很多问题，尤其是关于调整属性之后，并且给出了更多的示例\n新增BaseClipBorder 实现了新的控件BaseClipBorder来解决边框溢出和边框圆角缝隙的问题 最终实现如右图所示 优化ProgressBar 在上面BaseClipBorder的基础上优化了ProgressBar的实现 给出了垂直ProgressBar例程实现 新增DefaultControlStyle和DefaultWindowStyle 这样设计的原因其实是为了移除掉TextBlock的FontSize属性和FontFamily属性，改为直接从Window或者UserControl中继承字体属性。\n而DefaultControlStyle中定义了基础的FontSize和FontFamily样式，并且任何控件都可以使用。\n优化Button 删除了关于ButtonShape属性的内容 新增了一些无边框按钮的样式 统一了BorderBrush和BorderThickness的风格 优化ComboBox 重写了ComboBox的样式 新增ComboBoxItem的样式 新增InnerSeparator属性 新增BaseWPFControl:ControlProperty.InnerSeparator属性，一般用于内部存在间隙属性调整 1 2 3 \u0026lt;Button Content=\u0026#34;图标\u0026#34; Margin=\u0026#34;10\u0026#34; BaseWPFControl:ButtonProperty.Icon=\u0026#34;{StaticResource HomePage}\u0026#34; BaseWPFControl:ControlProperty.InnerSeparator=\u0026#34;20\u0026#34; /\u0026gt; 优化DataGrid 在使用DataGrid的时候，我发现有些属性没有效果，或者不尽如人意。\n所以我就重新整理了一下DataGrid的实现，并且给出了详细的案例。\n优化Calendar和Clock 优化FlipBox 新增Dialog显示成Window 可以调用ShowDialogAsWindow函数，将Dialog显示成独立的Window，就算没有DialogContainer也能显示。使用体验和WPF原生的ShowDialog函数类似。\n优化ListBox 和之前的显示一致，只是使用BaseClipBorder简化了内部实现。\n优化ListView 优化SmoothProgress 这里省事，直接让SmoothProgressBar使用ProgressBar的样式\n新增SimpleScrollViewer样式 该样式没有滚动条，只有箭头按钮，并且增加了滚动动画 主要用于TabControl的Header部分 优化TabControl 优化了微软原生样式下，TabItem溢出的问题 ","date":"2025-01-17T11:25:07+08:00","image":"https://zeroszhang.github.io/p/wpf%E6%8E%A7%E4%BB%B6%E5%BA%93-basewpfcontrol/Title.jpg","permalink":"https://zeroszhang.github.io/p/wpf%E6%8E%A7%E4%BB%B6%E5%BA%93-basewpfcontrol/","title":"WPF控件库 BaseWPFControl"}]